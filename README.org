* CLICK

Command Line Interface Common Kit

  - Purpose
    - CLICK answers the question: what 20%  does 80% of the work?
      - concepts
      - operations
      - packages
    - CLICK serves as an on ramp to CL concepts by assuming prior linux and programming knowledge
      - Only the initial setup and discovery of a CL environment is an obstacle.
      - Getting over this bump to the good stuff of Common Lisp should be made butttery smooth, it is worth it.
      - Assuming that users interested in CL have prior bash knowledge, is the key
    - CLICK butters daily tasks, such that the REPL becomes easier than terminal
      - So that projects can begin in the REPL and then grow into their potential
      - To prevent the all to common nightmare where a quick-experiment in bash becomes a monster

      CLICK is not meant to be a comprehensive introduction, or the ultimate
      library. These are my opinionated selections and most used examples that get
      me productive and learning through use. I enjoy the sprawling options and
      obscure tools that common lisp provides, but a focused on-boarding would
      have helped immensely.

      This is a Work In Progress

  - Future Contents
    - readme with basic linux operations especially notes on paths/dirs/files/fileio
    - basic package import and common usage reference
      - these will be opinionated selections of the single best modern approach
    - shell command wrappers for basic ops
    - a few helper functions for finding and printing and help discovery
    - everything you need in the first full week of using CL
    - anything you need everyday

      Note: let &&& be "right here completion needed" My default search
      highlights it. As long as I enter &&& I can jump away to chase another
      idea. When the search returns nothing I can assume 99% completeness.

* Startup

Nice intro
https://lisp-lang.org/

Mini spec - most used topics and examples
https://lamberta.github.io/minispec/

Questions and discovery
https://lisp-docs.github.io/

** SBCL

steel bank common lisp
https://www.sbcl.org/

install from command line
#+begin_src bash
sudo apt-get install sbcl
#+end_src

** lem

https://github.com/lem-project/lem/
TODO install guide

** quicklisp

https://www.quicklisp.org/beta/

install from command line
#+begin_src bash
curl -o /tmp/quick.lisp http://beta.quicklisp.org/quicklisp.lisp
sbcl --no-sysinit --no-userinit --load /tmp/quick.lisp \
       --eval '(quicklisp-quickstart:install :path "~/quicklisp")' \
       --eval '(ql:add-to-init-file)' \
       --quit
#+end_src

** ultralisp

https://ultralisp.org/

install from command line
#+begin_src bash
sbcl --eval '(ql-dist:install-dist "http://dist.ultralisp.org/" :prompt nil)' --quit
#+end_src

&&& dist order

** unix-in-lisp

https://github.com/PuellaeMagicae/unix-in-lisp

&&& install unix-in-lisp before evaluating clesh readtable?

libfixposix prereq
https://github.com/sionescu/libfixposix

#+begin_src bash
            mkdir ~/build-lfp
            git clone https://github.com/sionescu/libfixposix ~/build-lfp

          require:
          Xautoconf-2.67,
          Xautomake-1.10,
          Xlibtool-2.2.6b,
          Xpkg-config
          check

            cd ~/build-lfp
            autoreconf -i -f

            mkdir build
            cd build
            ../configure
            make
            make install

            #rm -r ~/build-lfp
#+end_src



clone the repo
#+begin_src bash
git clone https://github.com/PuellaeMagicae/unix-in-lisp ~/quicklisp/local-projects/unix-in-lisp/
#+end_src

dependencies are on ultralisp
#+begin_src lisp
(ql:quickload "unix-in-lisp")
#+end_src

for better SLIME integration. To load it, evaluate in emacs.
You may want to add this line to your init.el
#+begin_src lisp
(require 'unix-in-slime "~/quicklisp/local-projects/unix-in-lisp/unix-in-slime")
#+end_src

to start a listener =M-x unix-in-sime=

unix-in-slime installs hacks to the host Lisp environment by calling
=(unix-in-lisp:install)=
on startup. To undo hacks done to the host environment
and unmount Unix FS packages, run
=(unix-in-lisp:uninstall)=

This may replace all the functions below,
working on a function that deploys and starts

** load CLICK

TODO upload to ultralisp.
This will have to be loaded manually for now.
#+begin_src bash
  git clone https://github.com/lamb-duh/click ~/quicklisp/local-projects/click
#+end_src

evaluate &&& how to open the editor &&& how to eval
#+begin_src lisp
    (ql:quickload :click)
    (usepackage :click)
#+end_src

* Shell Operations

Many people want to check out Lisp, and could justify it if they were just
poking around, nothing serious though. I aim to make that easy. 90% of projects
begin in shell, just poking around, I certainly have no ulterior motives.

Standard shell commands should feel native. Anybody with programming/bash
experience should be immediately at home on the CL REPL. Initially These can be simple wrappers, the goal
is to eventually have them all in portable common lisp, and have each doc-string
describe the canonical CL approach.

Commands are moved through the sections as they are worked on.

** Planned

1. tar
2. gzip
3. ps
4. htop
5. kill
6. df
7. du
8. ifconfig
9. wget
10. curl
11. cut
12. sed

** First Implemented
The command is implemented to provide simple function. Use at your own risk and test as you go.
It may be a wrapper, its limitations should be noted in docstring

1. sort
2. wc
3. uniq
4. time
5. head
6. tail
7. rm
8. uname
9. date
10. find
11. whoami
12. cp
13. mv
14. cat
15. grep (file grep, needs to map ppcre string matching for composability)
16. which
17. echo
18. mkdir
19. rmdir
20. touch
21. chmod
22. chown
23. ls

** Tested
The command works as it should, if any functionality is missing it is noted in docstring.

1. pwd
2. cd

** Docstring is educative
The docstring educates the user on cannonical CL approaches.
The convenience commands should move the user toward the language.
May still be wrapper though
** Portable Cannonical
The command is not a wrapper, its function is implemented in CL
* System Concepts

In the core of lisp the meta circular evaluator was discovered by John Mcarthy;
from system primitives lisp develops a self evaluator for the language, and then builds out to
create the language. The implication of this is that lisp is built ON lisp, and
when you work you will be working ON the language. You are outside a set of
tools building and refining tools to move up and out. This is profoundly
different from working in a language. For other programming scenarios we work
within the constraints of the language. We work on one program, in a language
which is in turn inside the operating system.

When we work on lisp we are inside the image. Outside the image is the OS handling
multi tasking. The running lisp image is best though of as like an OS, not
quite, but almost. Inside the image is a place for programs, programs, we are
not restricted to a single program. This is why the order of function
definition doesn't matter, all the functions are compiled into the image,
multiple programs in one document can exist within the image at one time. The
running image for us has an interactive repl, functions, programs, scheduled
tasks, individual functions can be hot recompiled while the image
runs. Essentially, we have at our disposal a language we can modify to fit any
domain specific purpose, within a live system that we can interactively design to
accomplish a task or behaviour, including running multiple programs
simultaneously. When the goal is reached, that image can be exported as is, for
distribution. Yes that could be a simple script, an app, or an OS.

Freedom, sometimes means being lost. many operations we take for granted as
necessarily being bound together are orthogonal in CL.
- import is independent of use
- chdir is independent of *default-directory-defaults*
- in-package for the code is indpendent of in-package for the REPL
- &&&
Many granular steps are available and required to precisely specify the system,
none of this is particularly verbose, but it does require a change of details to
attend to. If something is not working as expected, I check what actions I have
assumed are accomplished by some explicit command.

** Importing

&&& packages are sets of symbols

&&& entering and using packages (load &&&) is not (use-package :eat-me) is not (in-package :drink-me)

#+begin_src lisp
                                           ; import and load
   (ql:quickload :cmd)
   (ql:quickload :file-finder)
   (ql:quickload :str)

                                           ; &&& load local file

                                           ; package def
   (defpackage :click
                                           ; whole package import
     ;; use cl to bring in basic functions
     (:use :cl :str :cmd :file-finder)
                                           ; shadowing
     ;; in this eg file-finder and cmd conflicted for current directory, with an error
     ;; cmd is now selected and the error no longer appears
     (:shadowing-import-from :cmd :current-directory)
                                           ; specific function import to this namespace
     (:import-from :uiop
      :subdirectories :directory-files :getcwd)
                                           ; functions to export from the package
     (:export
      :pwd
      :ls
      :cd
      :cat
      :grep
      :which
      :echo
      :*default-pathname-initialized*
      :*default-pathname-starts*
      ))

                                           ; enter package
   (in-package :click) ; Also enter this in the REPL!
#+end_src

** REPL and error and messages
- editor function
  - https://lispcookbook.github.io/cl-cookbook/emacs-ide.html

- interact with the repl
  - &&&
- move around in error message
  - &&&
- Observe objects:
  - (inspect "string")
  - (describe "string")
  - (apropos "string")
  - (documentation "string")
- Evaluate single form in place: =,-e-c=

** Pathnames

Common Lisp is older than any of the file systems in use today, its pathname
system is still more powerful and still relevant to every possible system. That
is a clue that there are some significant differences in how this is being
acomplished, some will not be intuitive.
https://lispcookbook.github.io/cl-cookbook/files.html
is essential reading, twice.

These tools cover far MORE than linux can acomplish with a filesystem. Clarifying
and reducing initial friction for file and dir ops is one of the major objectives of
this project.
- https://github.com/Shinmera/pathname-utils
- https://edicl.github.io/cl-fad/
- https://github.com/Shinmera/filesystem-utils
- https://shinmera.github.io/file-attributes/
- https://osicat.common-lisp.dev/manual/osicat.html
- https://github.com/fosskers/filepaths
- https://codeberg.org/fourier/ppath
- https://asdf.common-lisp.dev/uiop.html

#+begin_src lisp
                                          ; pathname objects are not strings
  #P"/bin/"
  ;; subcomponents can be manipulated individually
  ;; inspect &&&

  ;; ~ for home
  (user-homedir-pathname)

  ;; . for this location
  (uiop:getcwd)


#+end_src

Override default-pathname-defaults
#+begin_src lisp
  ;; this guy causes issues if Im not paying attention
  (print *default-pathname-defaults*)

  ;; &&&note elsewhere how (print (foo)) is transparent, prints and passes (foo) through
  ;; very nice for debugging

  (uiop:with-current-directory ("/bin")
    (print (uiop:getcwd))
    (directory-files "./"))

  (print (uiop:getcwd))

  (with-current-directory ("/tmp")
    (print (uiop:getcwd)))
#+end_src

** find-dir

  find-dir takes a list of paths and fuzzy filters directories, if depth is set it descends into directory tree,can be sequentially applied to its own output.

  arg : default action : description
  root : '(#P\"/\") : a list with paths or a path in #P or string form
  depth : 0 : an integer for retrieval depth below roots, default 0 goes no deeper for filtering root list
  keep : all : space delimited words to separately(additive to set) fuzzy filter in
  drop : none : space delimited words to separately(additive to set) fuzzy filter out, applied after keep
  report : none : set true for reporting on processing, big ass reports if depth is large
  n-test : off : integer for required num of paths in output list, error and report if not "

#+begin_src lisp

            (find-dir :keep "lib opt" :drop "etc lib gnu" :depth 2)
            (find-dir :report t :keep "lib opt" :drop "etc lib gnu" :depth 2)
            (find-dir :n-test 6 :depth 3 :keep "opt" :drop "gnu"  )
            (find-dir :drop "chrome"
                      :root (find-dir :depth 2
                                      :keep "opt"
                                      :drop "gnu"))


#+end_src

** finder
https://github.com/lisp-maintainers/file-finder/

convenience wrapper
=(finder (name~ "string")) => #F"file_object.type"=
granular control
=(finder* :predicates (name~ "string" ) :root <string | #P> ) => #F"file_object.type"=


Finder predicates
path
- =path~= matches when one of the path elements is contained in the file path.
- =every-path~= same checks on the file path, but uses a logical and.
- =path$= matches when one of the path suffixes matches the file path.

file name
- =name== matches when one of the names matches the file name (case sensitive).
  - full file name
- =iname== matches when one of the names matches the file name (case insensitive).
- =name~= matches when one of the names is contained in the file basename (and not the whole path), case sensitive.
  - partial name
- =iname~= matches when one of the names is contained in the file, case insensitive.
- =every-name~= same checks on the file basename, but uses a logical and.

extension
- =extension== matches file extensions
  -  full exact

recur predicates
- =depth<= matches when the argument file is in a subdirectory of ROOT less deep than LEVEL.
- =hidden?= return t if this is a hidden file

#+begin_src lisp
  (ql:quickload :file-finder)
  (use-package :file-finder)



  ;; basic
  (file-finder:finder* :root "/home/user/Downloads")
  (file-finder:finder* :predicates (file-finder:extension= "txt")
                       :root "/home/user/Downloads")
  ;; recur predicates
  (file-finder:finder* :predicates (file-finder:extension= "txt")
                       :recur-predicates (complement #'file-finder:hidden?)
                       :root "/home/user/Downloads")

  ;; predicates AND
  (finder* :predicates (list (name~ "test")
                             (extension= "txt"))
           :root "/home/user/Downloads")

  ;; call with find-dir for root
  (file-finder:finder* :predicates (file-finder:extension= "txt")
                       :root (first (find-dir :n-test 1
                                              :keep "Downloads"
                                              :depth 3)))


  ;; wrapper set interpretation is different
  ;; and
  (finder (<ff>)(<ff>))
  ;; or
  (finder (list (<ff>) (<ff>)))

  ;; convert results to string to use set operations
  ;; &&& is there a better way
  (mapcar #'namestring (finder &&&))
  (set-difference *), (union *)

  (set-difference
   (mapcar #'path (finder (path~ "index") (path~ "indices") (extension= "tif")))
   (mapcar #'path (finder (path~ "tiles")))
   :test #'equal)
#+end_src

** Dir Operations
Some operations use the default-pathname-defaults variable to establish the starting point, not all.
Online commentary defining paths from root is guaranteed consistent. I just set it consistently, it is wrapped in the (cd "str") function.

#+begin_src lisp
  (defparameter *my-starting-dir* (uiop:getcwd))

  ;; ls -d
  (directory "*") ; the syntax is badly documented(online) check

  (uiop:subdirectories (user-homedir-pathname))
  (uiop:subdirectories #P"/home/user/")
  (uiop:subdirectories "/home/user/")

  ;; pwd
  (uiop:getcwd)

  ;; cd
  (uiop:chdir #P"/path/name")
  (setf *default-pathname-defaults*(uiop:getcwd))


  ;; path to string
  (namestring "/home/user/")
  (namestring "#P/home/user/")
  (namestring (user-homedir-pathname))

  ;; string to path
  (pathname "/home/user")
  (pathname "/home/user/")
  (pathname #P"/home/user/")
  (pathname (user-homedir-pathname))


#+end_src

** File Operations

#+begin_src lisp
  ;; ls -f
  (directory-files &&&)

  ;; &&& move rename delete
#+end_src

** File IO

#+begin_src lisp
  (defparameter *file* #p"/home/user/test.txt")
  (print *file*)
  (uiop:read-file-lines *file*)

                                          ; open files
  (with-open-file (stream "test.txt" :direction :output
                                     :if-exists :supersede)
    (write-line "Hello, World!" stream))

  (with-open-file (stream "test.txt"
                          :direction :input
                          :if-does-not-exist :error)
    (let ((contents (make-string (file-length stream))))
      (read-sequence contents stream)
      (print contents)))

  (with-open-file (stream filename)
    (iter (for line = (read-line stream nil))
          (while line)
          (format t "~A%~%" line)))
#+end_src

* Syntax Concepts
Functions within functions within functions. Look inward.
** Parentheses are just trees
Don't look at the parens, look at the indentation and see the tree.
The abstract syntax tree is immediately available to the programmer and to the program

Math example
#+begin_src lisp

  (+ (* 3 4) (- 10 5) (/ 12 (+ 2 2)))

  ;; math is just a tree of operations
  (+ (* 3
        4)
     (- 10
        5)
     (/ 12
        (+ 2
           2)))
#+end_src

Nested lists example
#+begin_src lisp
  (defvar *tree* '(A(B(D)(E))(C(F)(G)(H))))

  ;; data is just a tree of relationships
  (A
   (B
    (D)
    (E))
   (C
    (F)
    (G)
    (H)))
#+end_src

Tree traversal example
#+begin_src lisp
  ;; code is just trees of steps
  (defun traverse (tree)
    (when tree                        ;stops when nothing
      (if (atom tree)                 ;test for a leaf node
          (print tree)                ; true, print the leaf
          (progn                      ; else, do these things
            (print (car tree))        ;  print parent before decending
            (traverse (cdr tree)))))) ;  descend into the remainder of the tree
#+end_src

Q: If code is just trees, and data and calculations are just trees
and we have code that walks into a tree
does that mean a program could go into a program?
could a program treat a program like data and change it?

A: It is just a tree, code is data, data is code.

** defparameter vs defvar
Clarify which is immutable
** args

#+begin_src lisp
  ;; arguments
  ;ordered binding
  (defun example-function (required &optional (optional-arg nil optional-arg-supplied-p))
    (if optional-arg-supplied-p
        (format t "Optional argument was supplied: ~A~%" optional-arg)
        (format t "Optional argument was not supplied~%")))
  ; :keyword binding
  (defun example-function (&key (keyword-arg nil keyword-arg-supplied-p))
    (if keyword-arg-supplied-p
        (format t "Keyword argument was supplied: ~ A~%" keyword-arg)
        (format t "Keyword argument was not supplied~%")))

  ;; &&& note on the undefined combination ? &optional &rest
  ;; &&& &rest &body etc
#+end_src

** functions

#+begin_src lisp
;; local functions
(defun example-flet ()
  (flet ((local-func (x) (* x 2)))
    (local-func 5)))

(defun example-labels ()
  (labels ((a () (print "In A")))
    (a)))

(defun example-labels-mutual ()
  (labels ((a () (print "In A"))
           (b () (a)))
    (b)))
#+end_src

** returns

#+begin_src lisp
;; let return
(let ((a 3)) a) ; => 3
#+end_src

** errors

#+begin_src lisp
;;simple errors
(error "This is an error message")
(error "Problem with x=~D and y=~S" x y)
;;specific error types:
(signal 'type-error (list :expected-type 'number :datum "not a number"))
;;For custom errors, define a condition and use `error` with it:
(define-condition my-custom-error (error) ())
(error 'my-custom-error)
#+end_src

** quoting data
** logic
** control
* Interop
** Cmd
Calls to command line, protected and various return types
https://github.com/ruricolist/cmd

#+begin_src lisp
                                          ; Loading
  (ql:quickload :cmd)
  (use-package :cmd)

                                          ; Usage
  ($cmd "ls")
  ($sh "cd ~; ls")
  ($sh "pwd")
  ($cmd "echo a b \
                    c \
                    d")

  ($cmd "echo 'hello world' >> text.txt")
  ($cmd "echo 'hello world' > text.txt")

  (defun call-cmd (arg arg1)
    ($cmd (format nil "echo hello:
                                   ~A
                                   ~A" arg arg1)))
  (call-cmd "Lamb" "Duh")

                                          ; &&& return types
  (cmd "cmd")
  ($cmd "cmd")
  ($sh "cmd")

#+end_src

** py4cl
Calls to and imports from Python
https://github.com/digikar99/py4cl2
#+begin_src lisp
                                          ; Load
  (ql:quickload :py4cl)

                                          ; test setup finds python on path
  (py4cl:python-version-info) ; fails if python command is not resolved in system
  (print py4cl:*python-command*)
  (setf py4cl:*python-command* "python3")
  (py4cl:python-version-info)
  (py4cl:import-module "math")
  (py4cl:python-eval "math.pi")

                                          ; &&&usage
  (py4cl:import-module "numpy" :as "np")
  (py4cl:python-eval "[i**2 for i in range(5)]") ; => #(0 1 4 9 16)
#+end_src

** Clesh
https://github.com/Neronus/clesh
clesh is included here mostly to show off how
flexible lisp can be, this is almost unthinkable in other languages, yet it is
transparently available without core language changes.

I recommend using cmd over clesh for permanent work, but for experimental, fast
tasks, scripts etc this mixed inlining is very handy indeed. cmd is more
controlable and disciplined and better suited for wrapping calls for serious
use.

#+begin_src lisp
                                          ; load
  (ql:quickload :clesh)
  (use-package :named-readtables)
  (in-readtable clesh:syntax)

                                          ; usage
  ;; repl out
  !ls
  !echo ?(+ 2 3) foo 5 bar

  ;;messages out
  [echo one two three] ;call bash command
  [echo one ?(+ 1 1) three] ;call lisp command in bash command
  (princ [echo foo]) ;call bash command in lisp command

  (defparameter *val* 42)
  [echo one ?*val* three] ;sub lisp var in bash arg
  [echo one ?(princ *val*) three] ;sub lisp command in bash arg

  ;; break bash commands
  [echo one \
  two \
  three]

  (princ [echo one \
         ?*val* \
         three]) ;sub lisp var in bash arg

  (princ [echo one \
         ?(+ *val* *val*) \
         three]) ;sub lisp command in bash arg

  ;; within a function
  (defun call-clesh (arg arg1)
    [echo \
    Hello: \
    ?arg \
    "FOO" ?arg1])
  (call-clesh "Lamb" "Duh")
#+end_src

** Scripting with CL

*** guides

-  sly adapted as shell https://web.archive.org/web/20210730202847/https://ambrevar.xyz/lisp-repl-shell/index.html
- https://simonsafar.com/2021/lisp_scripting/
- https://fare.livejournal.com/184127.html
- https://atomized.org/blog/2020/07/06/common-lisp-in-practice/
- shell wrapper https://www.cliki.net/CL-Launch

*** command line args

unix-opts
https://github.com/libre-man/unix-opts

The UNIX command line args can be read from the variable =sb-ext:*posix-argv*=

*** export binaries

(uiop/image: &&&)

** &&& clojure R etc
TODO Unified example of library interop, and program interop to minimal program with one argument for each lang
* Packages

TODO dig into ciel-lang, for inspiration and spare parts and packages
It looks like a well intentioned project but the deployment is awfull.
https://github.com/ciel-lang/CIEL

** strings

str
https://github.com/vindarel/cl-str

(str:split " " "hello world") ; => ("hello" "world")
(str:replace-all old new string)
(str:lines &&&)

regex
https://edicl.github.io/cl-ppcre/

time
https://local-time.common-lisp.dev/

** Testing
https://github.com/lmj/1am
https://github.com/AccelerationNet/lisp-unit2
** GUI

clog common lisp omnificient gui
https://rabbibotton.github.io/clog/cltt.pdf

** Logging

https://shinmera.github.io/verbose/

** iteration
*** built in

#+begin_src lisp
  ;;dotimes
  (dotimes (n 3)
    (print n))

  ;;dolist
  (dolist (i '(1 2 3))
    (print i))

  ;;mapcar
  (mapcar #'print '(1 2 3))

  ;; There is also the built in loop macro, its syntax is powerful, but non idiomatic
#+end_src

*** iterate

https://iterate.common-lisp.dev

#+begin_src lisp
  (ql:quickload "iterate")
  (use-package :iterate)

                                          ; Simple iteration over a range:
  (iter (for i from 1 to 10)
        (sum i))

                                          ; Simple iteration over a list:
  (iter (for x in '(1 2 3 4 5))
        (sum x))

                                          ; Iterating over a range of numbers:
  (iter (for i from 1 to 5)
        (collect (* i i)))

  (iter (for i from 1 to 5)
        (sum (* i i)))

                                          ; Iterating over a hash table:
  (let ((ht (make-hash-table)))
    (setf (gethash 'a ht) 1
          (gethash 'b ht) 2
          (gethash 'c ht) 3)
    (iterate (for (k v) in-hashtable ht)
             (collect (list k v))))
                                          ; => ((C 3) (B 2) (A 1))

                                          ; Nested iteration:
  (iter (for i from 1 to 3)
           (collect (iterate (for j from 1 to i)
                             (collect j))))
                                          ; => ((1) (1 2) (1 2 3))
#+end_src

** event scheduling

cl-schedule
https://github.com/jcguu95/cl-schedule

Initialization functions custom to click
- on-start
- on-target

** database

mito
https://github.com/fukamachi/mito

** math

in hyperspec as numbers
https://novaspec.org/cl/12_1_Number_Concepts

** data structures

reading
- https://blog.djhaskin.com/blog/common-data-structures-in-common-lisp/

access uniformity
https://github.com/AccelerationNet/access/

fset
https://github.com/slburson/fset

gmap
https://github.com/slburson/misc-extensions

listopia
https://github.com/Dimercel/listopia

*** a and p lists

&&&

*** hashtables

#+begin_src lisp
                                          ; Creating and using a simple hashtable:
  (defvar *fruit-prices* (make-hash-table :test #'equal))

  (setf (gethash "apple" *fruit-prices*) 0.50)
  (setf (gethash "banana" *fruit-prices*) 0.75)

  (format t "An apple costs $~A~%" (gethash "apple" *fruit-prices*))

                                          ; Using gethash with a default value:
  (defvar *user-scores* (make-hash-table))

  (setf (gethash "Alice" *user-scores*) 100)

  (format t "Bob's score: ~A~%" (gethash "Bob" *user-scores* 0))

                                          ; Iterating over a hashtable:
  (defvar *capitals* (make-hash-table :test #'equal))
  (setf (gethash "France" *capitals*) "Paris"
        (gethash "Japan" *capitals*) "Tokyo")

  (maphash #'(lambda (country capital)
               (format t "The capital of ~A is ~A~%" country capital))
           ,*capitals*)

                                          ; Removing an entry and checking the count:
  (defvar *inventory* (make-hash-table))
  (setf (gethash 'book *inventory*) 5
        (gethash 'pen *inventory*) 10)

  (remhash 'book *inventory*)
  (format t "Items in inventory: ~A~%" (hash-table-count *inventory*))
#+end_src

** Data formats IO

json
https://github.com/Zulu-Inuoe/jzon/

csv
https://github.com/AccelerationNet/cl-csv

xlsx
https://github.com/defunkydrummer/lisp-xl
on github &&& install notes

** distribution

*** quicklisp

https://www.quicklisp.org/beta/
https://common-lisp-libraries.readthedocs.io/quicklisp/

check installed dists
(ql-dist:all-dists)

&&&note on
(quicklisp:update-all-dists)

&&& how to uninstal dists
&&&reinstall dists

*** ultralisp

https://ultralisp.org/

*** asdf

https://asdf.common-lisp.dev/

* Help

quicksearch
https://github.com/lisp-maintainers/quicksearch

TODO (help) and (help "symbol")
should be an interactive menu describing the options/ letting user go on to any or all sub
(help "help") should go give detailed descriptions of each  option

package help
symbol help
namespace help

#+begin_src lisp
  ;;search quicklisp dists for a package
  (ql:system-apropos "find-me")
  ;;search all dists and github for a package
  (quicksearch:quicksearch "find-me")

  ;;inspect
  (inspect "string")
  ;;describe
  (describe "string")
  ;;apropos
  (apropos "string")
  ;;documentation
  (documentation "string")
#+end_src

** Acknowledgements
Smarter programmers than I have gone these ways, I have made this because I am a simple and silly sheep.

** Resources

ESSENTIAL


syntax crash course
https://learnxinyminutes.com/docs/common-lisp/

lisp crash course
https://cs.gmu.edu/~sean/lisp/LispTutorial.html

use the cookbook
https://lispcookbook.github.io/cl-cookbook/

hyperspec
https://www.lispworks.com/documentation/HyperSpec/Front/

novaspec
https://novaspec.org/cl/

awesome common lisp list
https://github.com/CodyReichert/awesome-cl

defacto libraries docs page
https://common-lisp-libraries.readthedocs.io/
- asdf - Build System
- alexandria - Commonly Used Utilities
- bordeaux-threads - Threading
- cl-ppcre - Regular Expressions
- cl-who - DSL for Markup
- fiveam - Regression Testing Framework
- hunchentoot - Web Server
- iterate - Psuedocodic Iteration
- local-time - Date and Time Manipulation
- postmodern - PostgreSQL programming interace
- quicklisp - Library Manager
- usocket - Universal Socket Library
- utilities - A collection of utility libraries
- numcl - Lispy clone of numpy
- unix-opts - cmd line argument parser



GUIDES
- great teacher https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/
- learn lisp the hard way https://llthw.common-lisp.dev/
- another terser cookbook https://cl-cookbook.sourceforge.net/index.html
- common lisp by example http://csci.viu.ca/~wesselsd/courses/csci330/code/sbcl-lisp/index.html
- successful lisp book https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/contents.html

WATCHING
- https://www.youtube.com/@the-lisper/videos
- https://www.youtube.com/watch?v=0RQYa2XJBKU
- https://www.youtube.com/@philipbohun740/videos
- https://www.youtube.com/watch?v=rmUTW5QWhhM&list=PL2VAYZE_4wRJi_vgpjsH75kMhN4KsuzR_&index=2

LIBRARIES
- asdf docs https://asdf.common-lisp.dev/
- alexandria docs https://alexandria.common-lisp.dev/draft/alexandria.html

REFERENCE
- common lisp wiki, almost every CL package https://www.cliki.net/
- technical syntax quick reference http://clqr.boundp.org/clqr-a4-consec.pdf
- sbcl man http://www.sbcl.org/manual
- quicklisp links to docs https://quickref.common-lisp.net/index-per-library.html
- quicklisp catalogue https://www.quicklisp.org/beta/UNOFFICIAL/docs/
- quicklisp search https://quickdocs.org/
- ql heavy hitters https://github.com/vindarel/lisp-maintainers
- documentation redirect service http://l1sp.org/html/
- googles lisp style guide https://google.github.io/styleguide/lispguide.xml
- style guide http://mumble.net/~campbell/scheme/style.txt

READING
- advanced functional programming https://www2.cs.sfu.ca/CourseCentral/310/pwfong/Lisp/2/tutorial2.html
- page 13 explained in pythoooon https://michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/
- page 13 in modern scheme https://www.gnu.org/software/mes/manual/html_node/LISP-as-Maxwell_0027s-Equations-of-Software.html
- LOL book https://letoverlambda.com/index.cl/toc
- blog and lisp bibliography https://simondobson.org/writing/
- lisp nn from primitives https://woodrush.github.io/blog/posts/2022-01-16-neural-networks-in-pure-lisp.html
- interactive programming implications https://www.n16f.net/blog/interactive-common-lisp-development/

CITATIONS FOR LISP PAPERS
- https://www.math.fau.de/wp-content/uploads/2020/09/Preprint-2002-40-scan.pdf
&&& bring other lisp citations here!

* CLEAN
Common Lisp Environment for Experiment and Analysis

All advanced data science ML and modelling goes here
If click is the living room clean is the laboratory

I want an operating system for data science,
deployable pipelines and experiment tracking is the goal

declarative file system state
https://github.com/Virtual-Insurance-Products/cl-sysop

Depot
file system protocol browse read write with locks and ACID safety
https://shinmera.github.io/depot/

clml machine learning
https://github.com/mmaul/clml

cl-ana
data frames stats and dependency oriented programming
https://github.com/ghollisjr/cl-ana/wiki

memoization
https://github.com/AccelerationNet/function-cache

ML
https://github.com/melisgl/mgl

nvidia interop
https://github.com/takagi/cl-cuda

lispstat - linear algebra - stats - plot
https://lisp-stat.dev/
#+begin_src lisp
                                          ; RE bug on loading in guix
                                          ; Cffi path Ref: https://lists.gnu.org/archive/html/bug-guix/2020-01/msg00133.html
(ql:quickload :lisp-stat) ; stats

                                          ; usage&&&
#+end_src

deep learning matrices matrices
https://github.com/hikettei/cl-waffe2

syntax modification useful for data pipelines
https://quickref.common-lisp.net/arrows.html

numcl, numpy clone
https://numcl.github.io/numcl/
#+begin_src lisp
                                          ; Creating and manipulating arrays:
  (numcl:array '(1 2 3 4 5))  ; Create a 1D array
  (numcl:zeros '(3 3))        ; Create a 3x3 array of zeros
  (numcl:aref my-array 1 2)   ; Access element at row 1, column 2

                                          ; Basic operations:
  (numcl:+ (numcl:array '(1 2 3)) (numcl:array '(4 5 6)))  ; Element-wise addition
  (numcl:* (numcl:array '(1 2 3)) 2)                       ; Scalar multiplication

                                          ; Mathematical functions:
  (numcl:sin (numcl:array '(0 (/ pi 2) pi)))  ; Element-wise sine
  (numcl:exp (numcl:array '(0 1 2)))          ; Element-wise exponential

                                          ; Linear algebra:
  (numcl:matmul matrix1 matrix2)  ; Matrix multiplication
  (numcl:transpose my-matrix)     ; Matrix transposition
#+end_src

&&& gnu scientific library for cl

System info
https://github.com/Shinmera/machine-state/

** lparallel

#+begin_src lisp
                                          ; lparallel startup
  (ql:quickload :lparallel)
  (use-package :lparallel)
  (setf lparallel:*kernel* (lparallel:make-kernel 8)) ;set worker threads

                                          ; env setup for examples
  (defun gt-five (x)
    (if (> x 5)
        x))

  (defun lt-five (x)
    (if (< x 5)
        x))

  (defparameter *mylist* '(0 1 2 3 4 5 6 7 8 9 10) )

                                          ; usage
  (pmap 'list (lambda (x) (* x x)) '(1 2 3 4))
  (preduce #'+ #(1 2 3 4 5))

  (premove '5 '(1 2 3 4 5 6 7 8 9 0))

  (premove-if (lambda (x) (> x 5)) '(0 1 2 3 4 5 6 7 8 9 10))
  (premove-if #'gt-five '(0 1 2 3 4 5 6 7 8 9 10))
  (premove-if #'gt-five *mylist*)

  (premove-if-not #'gt-five *mylist*)
  (premove-if #'gt-five *mylist*)
  (premove-if #'lt-five *mylist*)
  (premove-if-not #'lt-five *mylist*)

  (defun my-filter (predicate list)
    (reduce 'nreconc
            (lparallel:preduce-partial (lambda (acc x)
                                         (if (funcall predicate x)
                                             acc
                                             (cons x acc)))
                                       list
                                       :initial-value nil)
            :initial-value nil
            :from-end t))

  (my-filter #'gt-five *mylist*)
  #+end_src

** generators

gtwiwtg - generators the way I want them generated
https://github.com/d3v3l0/gtwiwtg
https://cicadas.surf/cgit/colin/gtwiwtg.git/about/
clear and modernized and documented


series
https://github.com/rtoy/cl-series
A high quality high perf, classic lib but docs and examples are hard to find

** types

coalton
https://github.com/coalton-lang/coalton/
