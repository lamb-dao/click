* CLICK

Command Line Interface Common Kit

  - Purpose
    - CLICK answers the question: what 20%  does 80% of the work?
      - concepts
      - operations
      - packages
    - CLICK serves as an on ramp to CL concepts by assuming prior linux and programming knowledge
      - Only the initial setup and discovery of a CL environment is an obstacle.
      - Getting over this bump to the good stuff of Common Lisp should be made butttery smooth, it is worth it.
      - Assuming that users interested in CL have prior bash knowledge, is the key
    - CLICK butters daily tasks, such that the REPL becomes easier than terminal
      - So that projects can begin in the REPL and then grow into their potential
      - To prevent the all to common nightmare where a quick-experiment in bash becomes a monster

      CLICK is not meant to be a comprehensive introduction, or the ultimate
      library. These are my opinionated selections and most used examples that get
      me productive and learning through use. I enjoy the sprawling options and
      obscure tools that common lisp provides, but a focused on-boarding would
      have helped immensely.

      This is a Work In Progress

  - Future Contents
    - readme with basic linux operations especially notes on paths/dirs/files/fileio
    - basic package import and common usage reference
      - these will be opinionated selections of the single best modern approach
    - shell command wrappers for basic ops
    - a few helper functions for finding and printing and help discovery
    - everything you need in the first full week of using CL
    - anything you need everyday

      Note: let &&& be "right here completion needed" My default search
      highlights it. As long as I enter &&& I can jump away to chase another
      idea. When the search returns nothing I can assume 99% completeness.

* Startup

Nice intro
https://lisp-lang.org/

Mini spec - most used topics and examples
https://lamberta.github.io/minispec/

Questions and discovery
https://lisp-docs.github.io/

** SBCL

steel bank common lisp
https://www.sbcl.org/

install from command line
#+begin_src bash
sudo apt-get install sbcl
#+end_src

** Spacemacs

TODO install guide
TODO basic CL dotfile guide

** quicklisp

https://www.quicklisp.org/beta/

install from command line
#+begin_src bash
curl -o /tmp/quick.lisp http://beta.quicklisp.org/quicklisp.lisp
sbcl --no-sysinit --no-userinit --load /tmp/quick.lisp \
       --eval '(quicklisp-quickstart:install :path "~/quicklisp")' \
       --eval '(ql:add-to-init-file)' \
       --quit
#+end_src

** ultralisp

https://ultralisp.org/

install from command line
#+begin_src bash
sbcl --eval '(ql-dist:install-dist "http://dist.ultralisp.org/" :prompt nil)' --quit
#+end_src

&&& dist order

** load CLICK

TODO upload to ultralisp.
This will have to be loaded manually for now.
#+begin_src bash
  git clone https://github.com/lamb-duh/click ~/quicklisp/local-projects/click
#+end_src

&&& how to open the editor
&&& how to eval

evaluate
#+begin_src lisp
    (ql:quickload :click)
    (usepackage :click)
#+end_src

* Shell Operations

99% of my projects begin in shell, just poking around, I certainly have no
grand plans beyond inquiry, then some abomination of bash or poor perf python grows around
that beginning. I aim to make bootstrapping that exploratory phase easy in CL. My goal is to make evolution
from early inquiry to a fully fledged high perf program easy.

Basic shell commands should feel native. Anybody with programming/bash
experience should be immediately at home on the CL REPL. Initially These can be
simple wrappers, the goal is to eventually have them all in portable common
lisp, and have each doc-string describe the canonical CL approach. Ideally I
would love to wrangle the best parts of nushell to this kit as well.

** Implemented

- builtins that wont be overridden
  - sort
  - time
  - find

1. pwd
2. ls
3. cd
4. which
5. cat
6. head
7. tail

** Not implemented
Listed in priority order from partially completed to planned. In code move status headings down as completion progresses.

1. rm
2. mv
3. cp
4. touch
5. rmdir
6. mkdir
7. echo
8. chown
9. chmod
10. grep (file grep, needs to map ppcre string matching for composability)
11. wc
12. uniq
13. whoami
14. date
15. uname

* System Concepts
** Intro
In the core of lisp the meta circular evaluator was discovered by John Mcarthy;
from system primitives lisp develops a self evaluator for the language, and then builds out to
create the language. The implication of this is that lisp is built ON lisp, and
when you work you will be working ON the language. You are outside a set of
tools building and refining tools to move up and out. This is profoundly
different from working in a language. For other programming scenarios we work
within the constraints of the language. We work on one program, in a language
which is in turn inside the operating system.

When we work on lisp we are inside the image. Outside the image is the OS handling
multi tasking. The running lisp image is best though of as like an OS, not
quite, but almost. Inside the image is a place for programs, programs, we are
not restricted to a single program. This is why the order of function
definition doesn't matter, all the functions are compiled into the image,
multiple programs in one document can exist within the image at one time. The
running image for us has an interactive repl, functions, programs, scheduled
tasks, individual functions can be hot recompiled while the image
runs. Essentially, we have at our disposal a language we can modify to fit any
domain specific purpose, within a live system that we can interactively design to
accomplish a task or behaviour, including running multiple programs
simultaneously. When the goal is reached, that image can be exported as is, for
distribution. Yes that could be a simple script, an app, or an OS.

Freedom, sometimes means being lost. many operations we take for granted as
necessarily being bound together are orthogonal in CL.
- import is independent of use
- chdir is independent of *default-directory-defaults*
- in-package for the code is indpendent of in-package for the REPL
- &&&
Many granular steps are available and required to precisely specify the system,
none of this is particularly verbose, but it does require a change of details to
attend to. If something is not working as expected, I check what actions I have
assumed are accomplished by some explicit command.
** click custom

- *default-pathname-initialized*
  - root pathname for point of initization
  - immutable
- *default-pathname-project*
  - root pathname for project
  - mutable

- find-dir
  - fuzzy find directory
  - details below

- on-start
  - automatically invoked
  - sets pathname for *default-pathname-initialized*
  - sets pathname for *default-pathname-project*
  - updates all distributions
  - will have clerk jobs

- on-project
  - user invokes
  - sets pathname for *default-pathname-project*
  - will have clerk jobs

- p
  - minimal keystoke maximal utility print parser
  - not implementd

- help
  - interactive help menu
  - not implemented

** Packages and imports

  lisp packages
  a container to group symbols together
    a symbol is a basic type denoting a funciton or a variable or other things

  a package is a first class object
  used as namespaces
  possible to create multiple packages per system/project

  initially the repl places the user in the cl-user package
  CL-USER> *package*
  cl-user contains basic functions variables and macros, defun etc

#+begin_src lisp
  (in-package :cl-user) ; make cl-user package available now
  (defpackage :my-package
    (:use :cl) ; :cl bring cl-user symbols into my-package
    (:export :*exported-symbol*))
  (in-package :my-package)

  ;; (export '*exported-symbol*) ;export in place or use :export in definition
  (defparameter *exported-symbol* 'hello)


  ;; check available symbols in a package
  (do-external-symbols (sym :cl)
    (print sym)) ; show current symbols ~1000

  (do-external-symbols (sym :my-package)
    (print sym)) ; our one symbol
#+end_src

Package symbols interaction details
#+begin_src lisp

                                          ; imports
  (ql:quickload :cmd)
  (ql:quickload :str)
  (ql:quickload :file-finder)
  (ql:quickload :com.inuoe.jzon)
                                          ; package declaration
  (defpackage :my-package
                                          ; whole package import
    (:use :cl :str :cmd :file-finder)
                                          ; shadowing, declares dominant function
    (:shadowing-import-from :cmd :current-directory)
                                          ; specific function import to this namespace
    (:import-from :uiop
     :subdirectories :directory-files :getcwd)
                                          ; rename package and or function
    (:local-nicknames (:jzon :com.inuoe.jzon))
                                          ; export functions and params to the click: name space
    (:export
     :my-function
     :*my-parameter*
     ))
                                          ; enter package
  (in-package :my-package) ; Also enter this in the REPL
  ;; to leave (in-package :cl-user), :my-package maintains state

                                          ; load local file
  (load (merge-pathnames #P"path/to/my-file.lisp" (uiop:getcwd)))
  #+end_src

** Loading Systems

Lisp systems
  system definition is declarative
  contains meta data of the project similar to debian packages
  possible to create multiple systems per asd file

it is default for the asd file to match the dir
- my-project (dir)
  - my-project.asd

#+begin_src lisp
  ;;an example my-project.asd file
  (defsystem :my-project
    :depends-on (:alexandria :str)
    ;; components in flat file system
    ;; - my-project.asd
    ;; - my-project.lisp
    ;; - README.org
    :serial t
    :components ((:file "my-project") ; a .lisp file
                 (:static-file "README.org"))
    ;; components in hierarchical file system
    ;; my-project.asd
    ;; - src
    ;;   - utils.lisp
    ;;   - my-project.lisp
    ;;   - config.lisp
    ;; - test
    ;;   - tests.lisp
    :serial t
    :components ((:module "src"
                  :components ((:file "utils")
                               (:file "my-project")
                               (:file "config")))
                 (:module "test"
                  :components tests)))
  ;; defsystem is capable of complex loading order dependencies

  ;; an example my-project.lisp file
  (in-package :cl-user)
  (defpackage #:my-package
    (:use :cl)
    (:export :my-function))
  (in-package :my-package)
  (defun my-function ()
    "an exported function"
    (print "hello world"))
#+end_src

Interactive loading
  clone a project to local, eg str
  cli nav to find system definintion, eg str.asd
  start a lisp
  $ sbcl
  CL-USER>
#+begin_src lisp
  ;;load system definition
  (asdf:load-asd "str.asd") ; use exact path

  ;; load system
  (asdf:load-system "&&&") ; will not load dependencies
  (asdf:system-depends-on (asdf:find-system "str")) ; list of dependencies

  (ql:quickload :str) ; recursively loads dependencies
  (in-package :str) ; enter the package to use internal functions

  ;; in emacs open str.asd file
  C-c C-k to compile and load

  (ql:quickload :str)
  (in-package ::str) or C-c ~
#+end_src

** REPL and error and messages
- editor function
  - https://lispcookbook.github.io/cl-cookbook/emacs-ide.html

- interact with the repl
  - &&&
- move around in error message
  - &&&
- Observe objects:
  - (inspect "string")
  - (describe "string")
  - (apropos "string")
  - (documentation "string")
- Evaluate single form in place: =,-e-c=

** Pathnames

Common Lisp is older than any of the file systems in use today, its pathname
system is still more powerful and still relevant to every possible system. That
is a clue that there are some significant differences in how this is being
acomplished, some will not be intuitive.
https://lispcookbook.github.io/cl-cookbook/files.html
is essential reading, twice.

These tools cover far MORE than linux can acomplish with a filesystem. Clarifying
and reducing initial friction for file and dir ops is one of the major objectives of
this project.
- https://github.com/Shinmera/pathname-utils
- https://edicl.github.io/cl-fad/
- https://github.com/Shinmera/filesystem-utils
- https://shinmera.github.io/file-attributes/
- https://osicat.common-lisp.dev/manual/osicat.html
- https://github.com/fosskers/filepaths
- https://codeberg.org/fourier/ppath
- https://asdf.common-lisp.dev/uiop.html

#+begin_src lisp
                                          ; pathname objects are not strings
  #P"/bin/"
  ;; subcomponents can be manipulated individually
  ;; inspect &&&

  ;; ~ for home
  (user-homedir-pathname)

  ;; . for this location
  (uiop:getcwd)


#+end_src

Override default-pathname-defaults
#+begin_src lisp
  ;; this guy causes issues if Im not paying attention
  (print *default-pathname-defaults*)

  ;; &&&note elsewhere how (print (foo)) is transparent, prints and passes (foo) through
  ;; very nice for debugging

  (uiop:with-current-directory ("/bin")
    (print (uiop:getcwd))
    (directory-files "./"))

  (print (uiop:getcwd))

  (with-current-directory ("/tmp")
    (print (uiop:getcwd)))
#+end_src

** find-dir

find-dir takes a list of paths and fuzzy filters directories, if depth is set it descends into directory tree,can be sequentially applied to its own output.

arg : default action : description
root : '(#P\"/\") : a list with paths or a path in #P or string form
depth : 0 : an integer for retrieval depth below roots, default 0 goes no deeper for filtering root list
keep : all : space delimited words to separately(additive to set) fuzzy filter in
drop : none : space delimited words to separately(additive to set) fuzzy filter out, applied after keep
report : none : set true for reporting on processing, big ass reports if depth is large
n-test : off : integer for required num of paths in output list, error and report if not "

#+begin_src lisp

  (find-dir :keep "lib opt" :drop "etc lib gnu" :depth 2)
  (find-dir :report t :keep "lib opt" :drop "etc lib gnu" :depth 2)
  (find-dir :n-test 6 :depth 3 :keep "opt" :drop "gnu"  )
  (find-dir :drop "chrome"
            :root (find-dir :depth 2
                            :keep "opt"
                            :drop "gnu"))


#+end_src

** finder
https://github.com/lisp-maintainers/file-finder/

convenience wrapper
=(finder (name~ "string")) => #F"file_object.type"=
granular control
=(finder* :predicates (name~ "string" ) :root <string | #P> ) => #F"file_object.type"=


Finder predicates
path
- =path~= matches when one of the path elements is contained in the file path.
- =every-path~= same checks on the file path, but uses a logical and.
- =path$= matches when one of the path suffixes matches the file path.

file name
- =name== matches when one of the names matches the file name (case sensitive).
  - full file name
- =iname== matches when one of the names matches the file name (case insensitive).
- =name~= matches when one of the names is contained in the file basename (and not the whole path), case sensitive.
  - partial name
- =iname~= matches when one of the names is contained in the file, case insensitive.
- =every-name~= same checks on the file basename, but uses a logical and.

extension
- =extension== matches file extensions
  -  full exact

recur predicates
- =depth<= matches when the argument file is in a subdirectory of ROOT less deep than LEVEL.
- =hidden?= return t if this is a hidden file

#+begin_src lisp
  (ql:quickload :file-finder)
  (use-package :file-finder)



  ;; basic
  (file-finder:finder* :root "/home/user/Downloads")
  (file-finder:finder* :predicates (file-finder:extension= "txt")
                       :root "/home/user/Downloads")
  ;; recur predicates
  (file-finder:finder* :predicates (file-finder:extension= "txt")
                       :recur-predicates (complement #'file-finder:hidden?)
                       :root "/home/user/Downloads")

  ;; predicates AND
  (finder* :predicates (list (name~ "test")
                             (complement (path~ "exclude"))
                             (extension= "txt"))
           :root "/home/user/Downloads")

  ;; call with find-dir for root
  (file-finder:finder* :predicates (file-finder:extension= "txt")
                       :root (first (find-dir :n-test 1
                                              :keep "Downloads"
                                              :depth 3)))


  ;; wrapper set interpretation is different
  ;; and
  (finder (<ff>)(<ff>))
  ;; or
  (finder (list (<ff>) (<ff>)))

  ;; convert results to string to use set operations
  ;; &&& is there a better way
  (mapcar #'namestring (finder &&&))
  (set-difference *), (union *)

  (set-difference
   (mapcar #'path (finder (path~ "index") (path~ "indices") (extension= "tif")))
   (mapcar #'path (finder (path~ "tiles")))
   :test #'equal)
#+end_src

** Dir Operations
Some operations use the default-pathname-defaults variable to establish the starting point, not all.
Online commentary defining paths from root is guaranteed consistent. I just set it consistently, it is wrapped in the (cd "str") function.

#+begin_src lisp
  (defparameter *my-starting-dir* (uiop:getcwd))

  ;; ls -d
  (directory "*") ; the syntax is badly documented(online) check

  (uiop:subdirectories (user-homedir-pathname))
  (uiop:subdirectories #P"/home/user/")
  (uiop:subdirectories "/home/user/")

  ;; pwd
  (uiop:getcwd)

  ;; cd
  (uiop:chdir #P"/path/name")
  (setf *default-pathname-defaults*(uiop:getcwd))


  ;; path to string
  (namestring "/home/user/")
  (namestring "#P/home/user/")
  (namestring (user-homedir-pathname))

  ;; string to path
  (pathname "/home/user")
  (pathname "/home/user/")
  (pathname #P"/home/user/")
  (pathname (user-homedir-pathname))


#+end_src

** File Operations

#+begin_src lisp
  ;; ls -f
  (directory-files &&&)

  ;; &&& move rename delete
#+end_src

** File IO

#+begin_src lisp
  (defparameter *file* #p"/home/user/test.txt")
  (print *file*)
  (uiop:read-file-lines *file*)

                                          ; open files
  (with-open-file (stream "test.txt" :direction :output
                                     :if-exists :supersede)
    (write-line "Hello, World!" stream))

  (with-open-file (stream "test.txt"
                          :direction :input
                          :if-does-not-exist :error)
    (let ((contents (make-string (file-length stream))))
      (read-sequence contents stream)
      (print contents)))

  (with-open-file (stream filename)
    (iter (for line = (read-line stream nil))
      (while line)
      (format t "~A%~%" line)))
#+end_src

** command line REPL

$ rlwrapper sbcl #allows readline support on terminal

CL-USER> (print "hello")
"hello" ; standard out
"hello" ; evaluation

=*= references last returned evaluation

** Interfacing emacs/code/REPL
pushing parens ahead around next form
go to source
l to move back in stack trace
slime-cd to change location
** Most common functions

1. defun - Define functions
2. let - Create local bindings
3. loop - Powerful iteration construct
4. if - Conditional execution
5. setf - Generalized assignment
6. mapcar - Apply function to each element of a list
7. format - Formatted output
8. cond - Multi-way conditional
9. defparameter - Define global variables
10. lambda - Create anonymous functions
11. when - Single-clause conditional
12. unless - Negated single-clause conditional
13. progn - Execute a series of forms sequentially
14. dolist - Iterate over list elements
15. cons - Construct lists
16. car/first - Access first element of a list
17. cdr/rest - Access rest of a list
18. print - Print Lisp objects to a stream
19. append - Combine lists
20. length - Get length of a sequence
21. list - return a list made of the arguments
22. nth - Access nth element of a list
23. push - Add an item to the front of a list
24. pop - Remove and return the first item of a list
25. aref - Access array elements
26. read - Read Lisp objects from a stream
27. find - Search for an item in a sequence
28. member - Check if an item is in a list
29. remove - Remove items from a sequence
30. funcall - Call function by variable
31. apply - Apply function to argument list
32. reduce - Reduce a list to a single value
33. sort - Sort a sequence
34. defmacro - Define macros
35. with-open-file - File I/O with automatic cleanup
36. equalp - General equality predicate
37. make-array - Create arrays
38. subseq - Extract a subsequence
39. typecase - Type-based conditional
40. make-hash-table - Create hash tables
41. gethash - Access hash table entries
42. defclass - Define classes (for CLOS)
43. make-instance - Create object instances
44. slot-value - Access object slots
45. values - Return multiple values
46. multiple-value-bind - Bind multiple values
47. defstruct - Define structures
48. declare - Declare variables or provide optimization hints
49. handler-case - Error handling
50. load - Load and execute Lisp code from a file
51. eval - Evaluate Lisp expressions at runtime
52. defmethod - Define methods for generic functions
53. destructuring-bind - Destructure complex data structures
54. macroexpand-1 - Expand a macro once
55. time - Measure execution time
56. intern - Create or locate a symbol
57. symbol-function - Access a symbol's function definition
58. gensym - Generate unique symbols
59. coerce - Convert between types
60. make-string - Create a string
61. string-trim - Remove characters from string ends
62. concatenate - Join sequences
63. position - Find position of an item in a sequence
64. reverse - Reverse a sequence
65. nreverse - Destructively reverse a sequence
66. assoc - Look up key-value pairs in an association list
67. every - Test if predicate is true for all elements
68. some - Test if predicate is true for any element
69. dotimes - Iterate a specified number of times
70. do - General iteration construct
71. acons - Add to an association list
72. copy-tree - Deep copy of a tree structure
73. remove-if - Remove elements satisfying a predicate
74. map - Apply function to elements of multiple sequences
75. char - Access character in a string
76. eq - Test for object identity
77. defgeneric - Define a generic function
78. make-list - Create a list of specified length
79. substitute - Replace items in a sequence
80. parse-integer - Parse string to integer
81. compile - Compile a function
82. documentation - Get or set documentation string
83. trace - Trace function calls
84. untrace - Untrace function calls
85. break - Enter debugger
86. describe - Display information about an object
87. type-of - Get type of an object
88. typep - Test if object is of a given type
89. restart-case - Define restarts for error handling
90. defpackage - Define a package
91. in-package - Switch to a package
92. merge - Merge sorted sequences
93. logior - Bitwise logical OR
94. logand - Bitwise logical AND
95. ash - Arithmetic shift
96. floor - Integer division with floor rounding
97. ceiling - Integer division with ceiling rounding
98. round - Round to nearest integer
99. random - Generate random number
100. constantly - Create constant function
101. identity - Identity function
102. flet - Define local functions
103. labels - Define locally recursive functions
104. evenp - Test if a number is even
105. oddp - Test if a number is odd
106. zerop - Test if a number is zero
107. plusp - Test if a number is positive
108. minusp - Test if a number is negative
109. max - Find maximum value
110. min - Find minimum value
111. remf - Remove a property from a property list
112. getf - Get a property value from a property list
113. pprint - Pretty print
114. apropos - Search for symbols
115. read-from-string - Read Lisp object from a string
116. write-to-string - Write Lisp object to a string
117. ignore-errors - Ignore errors in a form
118. nconc - Destructively concatenate lists
119. make-package - Create a new package
120. find-package - Find a package by name
121. export - Export symbols from a package
122. import - Import symbols into a package
123. shadow - Shadow inherited symbols
124. shadowing-import - Import symbols, shadowing existing ones
125. ensure-directories-exist - Create directories if they don't exist
126. probe-file - Check if a file exists
127. delete-file - Delete a file
128. rename-file - Rename a file
129. file-length - Get file size
130. file-position - Get or set file position
131. open - Open a file or stream
132. close - Close a stream
133. read-line - Read a line from a stream
134. write-line - Write a line to a stream
135. read-char - Read a character from a stream
136. write-char - Write a character to a stream
137. peek-char - Look at next character in stream without consuming it
138. listen - Check if input is available on a stream
139. clear-input - Clear input buffer
140. y-or-n-p - Ask a yes-or-no question
141. sleep - Pause execution for a specified time
142. get-universal-time - Get universal time
143. decode-universal-time - Convert universal time to decoded time
144. encode-universal-time - Convert decoded time to universal time
145. get-decoded-time - Get current time as decoded time
146. load-compiled - Load a compiled Lisp file
147. complement - Create complementary predicate function
148. count - Count occurrences in a sequence
149. count-if - Count elements satisfying a predicate
150. position-if - Find position of element satisfying predicate
151. remove-duplicates - Remove duplicate elements from a sequence
152. intersection - Set intersection of sequences
153. union - Set union of sequences
154. set-difference - Set difference of sequences
155. subsetp - Test if one set is a subset of another
156. force-output - Force output on a stream
157. finish-output - Finish pending output on a stream
158. fresh-line - Move to a fresh line on output
159. terpri - Terminate print line
160. princ - Print object readably
161. prin1 - Print object not readably
162. pprint-newline - Insert a newline in pretty printing
163. copy-seq - Create a copy of a sequence
164. mod - Modulus operation
165. fill - Fill a sequence with a value
166. replace - Replace part of a sequence with another
167. search - Search for a subsequence
168. mismatch - Find first mismatch between sequences
169. stable-sort - Stable sorting algorithm
170. merge-pathnames - Merge pathname with defaults
171. pathname - Create a pathname object
172. directory - List files in a directory
173. file-namestring - Get filename part of a pathname
174. file-author - Get file author
175. file-write-date - Get file modification time
176. user-homedir-pathname - Get user's home directory pathname
177. get-properties - Get multiple properties from property list
178. remprop - Remove a property from a symbol
179. symbol-plist - Get a symbol's property list
180. copy-symbol - Create a copy of a symbol
181. keywordp - Test if a symbol is a keyword
182. macro-function - Get macro function of a symbol
183. elt - Access sequence elements (more general than aref)
184. vector - Create a vector
185. string= - Compare strings for equality
186. string-equal - Compare strings ignoring case
187. string< - Compare strings lexicographically
188. parse-float - Parse string to float (often implemented as an extension)
189. defvar - Define global variables with optional initial value
190. make-string-input-stream - Create a string input stream
191. make-string-output-stream - Create a string output stream
192. get-output-stream-string - Get string from a string output stream
193. hash-table-count - Get number of entries in a hash table
194. clrhash - Clear a hash table
195. remhash - Remove an entry from a hash table
196. maphash - Iterate over hash table entries
197. get-internal-real-time - Get current time
198. room - Display memory usage information
199. functionp - Test if an object is a function
200. symbolp - Test if an object is a symbol
201. stringp - Test if an object is a string
202. numberp - Test if an object is a number
203. characterp - Test if an object is a character
204. arrayp - Test if an object is an array
205. listp - Test if an object is a list
206. atom - Test if an object is an atom (not a cons)
207. null - Test if an object is nil
208. equal - Test for structural equality
209. eql - Test for object identity or numeric equality
210. string-downcase - Convert string to lowercase
211. string-upcase - Convert string to uppercase
212. float - Convert a number to floating-point
213. abs - Absolute value
214. sqrt - Square root
215. expt - Exponentiation
216. incf - Increment a place
217. decf - Decrement a place
218. nthcdr - Get the nth cdr of a list
219. butlast - Return a list with the last n elements removed
220. last - Get the last cons cell of a list
221. compile-file - Compile a Lisp source file
222. disassemble - Display machine code for a compiled function
223. machine-type - Get machine type
224. software-type - Get operating system type
225. with-slots - Access slots of CLOS objects conveniently
226. make-sequence - Create a sequence of a given type and length
227. find-if - Find an element satisfying a predicate
228. remove-if-not - Keep elements satisfying a predicate
229. substitute-if - Substitute elements satisfying a predicate
230. defconstant - Define global constants
231. &rest - Special parameters for function definitions
232. &optional - Special parameters for function definitions
233. assert - Assertion macro for debugging and error checking
234. block - Named blocks and non-local returns
235. return-from - Named blocks and non-local returns
236. case - Switch-like conditional construct
237. error - Signal an error
238. warning - Signal a warning
239. with-open-stream - Similar to with-open-file, but for streams in general
240. mapcan - Like mapcar, but concatenates results
241. multiple-value-call - Call a function with multiple value returns

* Syntax Concepts
Functions within functions within functions. Look inward.
** Parentheses are just trees
Don't look at the parens, look at the indentation and see the tree.
The abstract syntax tree is immediately available to the programmer and to the program

Math example
#+begin_src lisp

  (+ (* 3 4) (- 10 5) (/ 12 (+ 2 2)))

  ;; math is just a tree of operations
  (+ (* 3
        4)
     (- 10
        5)
     (/ 12
        (+ 2
           2)))
#+end_src

Nested lists example
#+begin_src lisp
  (defvar *tree* '(A(B(D)(E))(C(F)(G)(H))))

  ;; data is just a tree of relationships
  (A
   (B
    (D)
    (E))
   (C
    (F)
    (G)
    (H)))
#+end_src

Tree traversal example
#+begin_src lisp
  ;; code is just trees of steps
  (defun traverse (tree)
    (when tree                        ;stops when nothing
      (if (atom tree)                 ;test for a leaf node
          (print tree)                ; true, print the leaf
          (progn                      ; else, do these things
            (print (car tree))        ;  print parent before decending
            (traverse (cdr tree)))))) ;  descend into the remainder of the tree
#+end_src

Q: If code is just trees, and data and calculations are just trees
and we have code that walks into a tree
does that mean a program could go into a program?
could a program treat a program like data and change it?

A: It is just a tree, code is data, data is code.

** Variables
defparameter vs defvar, both set global variables
defparameter is mutable
defvar is immutable

let is lexically scoped, valid within it range
let can dynamically redefine a global variable temporarilly

#+begin_src  lisp
(defparameter *my-param*) ;error requires binding
(defparameter *my-param* nil) ; bound to NIL
(defparameter *my-param* '()) ; bound to NIL
(defparameter *my-param* 42
  "doc for my-param")
(defparameter *my-param* 47
  "doc for my-param") ; rebound


(defvar *my-var*) ; success unbound at this point, not even nil
(defvar *my-var* 124) ; bound at this point
(defvar *my-var* 1) ; immutable, but no error on attempt

(let (a b)
  (setf a 1
        b 2)
  (format t " a: ~A b: ~A~&" a b))
(let ((a 3)
      (b 4 ))
  (format t " a: ~A b: ~A~&" a b))

(let* ((a 3)
       (b 4)
       (c (+ a b)))
  (format t " a: ~A b: ~A c: ~A~&" a b c))

(format t "outside the lexical scope before the let *my-param*: ~A~&" *my-param*)
(let ((*my-param* 11))
  (format t "only within the lexical scope of the let *my-param*: ~A~&" *my-param*))
(format t "outside the lexical scope after the let *my-param*: ~A~&" *my-param*)
#+end_src

** Conditions

#+begin_src  lisp
  (if (test)
      (then) ; or prog1 for then,continuing
      (else))

  (when (test)
    (then)
    (continuing)) ; implicit progn, no else
  ;; (unless) compliment of when

  (not (test)) ; compliment of test


  (cond ; returns first true block
    (test
        logic0
      logic1
      )
    (t :default))

  (case a
    (1
     :its1)
    (t :default))

  ;; conditional on environment
  *features* is a list of keywords anyone can add to it
  (push :my-feature *features*)
  #+unix
  (print "we are on unix")

  #-foo
  (print "of course there is no foo feature")

  #+(and unix my-feature)
  (print "we are on unix working on my-feature")
#+end_src
** args

#+begin_src lisp
  ;; arguments
                                          ;ordered binding
  (defun example-function (required &optional (optional-arg nil optional-arg-supplied-p))
    (if optional-arg-supplied-p
        (format t "Optional argument was supplied: ~A~%" optional-arg)
        (format t "Optional argument was not supplied~%")))
                                          ; :keyword binding
  (defun example-function (&key (keyword-arg nil keyword-arg-supplied-p))
    (if keyword-arg-supplied-p
        (format t "Keyword argument was supplied: ~ A~%" keyword-arg)
        (format t "Keyword argument was not supplied~%")))

  ;; &&& note on the undefined combination ? &optional &rest
  ;; &&& &rest &body etc
#+end_src

** functions

#+begin_src lisp
  ;; declaration
  (defun hello ()
    "docstring for hello"
    (format t "hello ~A" (uiop:getenv "USER")))
  (hello)

  ;; local functions
  (defun example-flet ()
    (flet ((local-func (x) (* x 2)))
      (local-func 5)))

  (defun example-labels ()
    (labels ((a () (print "In A")))
      (a)))

  (defun example-labels-mutual ()
    (labels ((a () (print "In A"))
             (b () (a)))
      (b)))




(defun hello (name &optional happy) ; optional nil by default
  (format t "hello ~A~&" name)
  (if happy ; when truthy
    (format t ":)")
    (format t ":(")))

(defun hello (name &key (happy "default value" happy-p))
  "doc string"
  (format t "hello ~A~&" name)
  (when happy-p ; when supplied
    (if happy
        (format t ":)")
        (format t ":(")) ))

(defun mean (x &rest numbers)
  "compute mean to demonstrate variadic num of args"
  (format t "&rest yields a list. numbers: ~A~&" numbers)
  (/ (apply #'+ x numbers)
     (1+ (length numbers))))

,-h-h slime-describe-symbol
(apropos "hello") ; loaded in image
(documentation 'hello 'function) ; a symbol
(documentation #'hello 'function) ; a function
;; it is meaningfully different to inspect the symbol vs the function
(inspect 'hello) ; show symbol attributes
(inspect #'hello) ; show function bindings
;; additionally ' mostly refers to toplevel bindings while #' respects lexical environment, flet etc
;; a source of subtle bugs
(describe #'hello) ; usually this is what you need

flet is like let, must be independent
labels is like let*, can refer to each other

;;multiple return values
(defun my-multiple-returns ()
  (let ((a 1)
        (b 2)
        (str "my-string"))
    (values a b str)))

  ;; not a list or tuple
(my-multiple-returns) ; => 1, 2, "my-string"
;; the return value is the first of values
CL-USER> * ; => 1
(nth-value 2 (my-multiple-returns))
(multiple-value-bind (0th 1th) ;  bind to local variables in order,  can bind part or all
    (my-multiple-returns)
  (print 0th)
  (print 1th))

;; higher order functions
(defun compute (x y &key (operation #'+))
   (funcall operation x y))
(compute 1 2)
(compute 1 2 :operation #'-)

(member "foo" '("foo" "bar"))
(member "foo" '("foo" "bar") :test #'string-equal)

(lambda (x) (1+ x))
CL-USER> (funcall * 2)

(compute 4 2 :operation (lambda (x y) (+ 10 x y)))

(defun generate-adder (step)
  (lambda (x)
    (+ x step)))

(generate-adder 10)

funcall and apply

;; closures
function closes over the environment

(let ((counter 0))
  (defun counter-inc ()
    (incf counter))
  (defun counter-init ()
      (setf counter 0))
  (defun counter-value ()
    counter))

(counter-inc)
(counter-value)
(counter-init)

;; returning closures
(defun make-looping-counter (limit)
  (let ((counter 0))
    (lambda ()
      (if (>= counter limit)
          (setf counter 0)
          (incf counter)))))
(defparameter *counter-to-2* (make-looping-counter 2))
(funcall *counter-to-2*)
(inspect *counter-to-2*)

;; setf functions
(let ((counter 0))
  (defun counter-inc ()
    (incf counter))
  (defun counter-init ()
      (setf counter 0))
  (defun counter-value ()
    counter)
  (defun (setf counter-value) (new-value) ; reuse accessor, supply value and any accessor arg
    (setf counter new-value)))

(counter-init)
(counter-inc)
(setf (counter-value) 6) ; setf the location provided by the accessor
(counter-value)


#+end_src

** returns

#+begin_src lisp
  ;; let return
  (let ((a 3)) a) ; => 3
#+end_src

** Errors and Handling
#+begin_src lisp

  ;;simple errors
  (error "This is an error message")
  (error "Problem with x=~D and y=~S" x y)
  ;;specific error types:
  (signal 'type-error (list :expected-type 'number :datum "not a number"))
  ;;For custom errors, define a condition and use `error` with it:
  (define-condition my-custom-error (error) ())
  (error 'my-custom-error)

  ;; create an error
  (error "Signals an error. The arg was: ~A" arg)
  (warn "carefull") ; no debugger
  ;; create object
  (make-condition 'simple-condition ) ; type one of: 'warn 'error 'simple-condition
  ;; signal it
  (signal *)
  signal then handle not throw catch

  (ql:quickload :log4cl)
  (defun f1 (&optional (arg 'nil))
    (error "Signals an error. The arg was: ~A" arg))
  (defun f2 ()
    "handle conditions with handle case"
    (handler-case
        (f1)
      (error (c) ; c for the condition we want to handle
        (log:info "We got an error: ~A" c))))

  (defun w1 ()
    (warn "Warning"))
  (defun f2 ()
    "handle conditions with handle case"
    (handler-case
        (w1)
      ;;doesnt catch warnings
      (error (c) ; c for the condition we want to handle
        (log:info "We got an error: ~A" c))
      (warning (c)
        (log:info "we got a warning: ~A" c))))

  ;; catch errors
  ;; handler-case
  ;; define errors
  ;; ignore-errors
  ;; unwind-protect
  ;; handler-bind
#+end_src

** Macros
#+begin_src lisp


macros do not evaluate their arguments, it is passed as is to the macro process
macros expand to function calls at compile time


(defmacro cube (x)
  `(* ,x ,x ,x))
(cube 2)

;;quote
;; quote does not evaluate its argument.

(list 1 a 2 b) ; > error on a unbound
(quote (list 1 a 2 b)) ; > (LIST A etc) list of symbols
'(list 1 a 2 b) ; > same

(list :a 1 :b 2) ; > (:A etc)
'(:a 1 :b 2) ; > same

(quote (list :a 1 :b 2)) ; > (LIST :A etc)
(eval (quote (list :a 1 :b 2))) ; > (:A etc) full circle

(let ((a 1)
      (b 2))
  (list 'a a 'b b)) ; > (A 1 B 2)


;;backquote and comma
;; do not require macros to use bq and comma
(let ((a 1)
      (b 2))
  `(:a ,a :b ,b)) ; > (:A 1 :B 2)

;; how to spot you are using a macro
non reqular lisp syntax eg loop macro
non regular paren nesting eg let
starts with 'with' eg with open file
new variable bindings eg dolist

;;macros vs functions

macros can not  be used as HOF
funcall, mapcar, apply etc
(defmacro cube (x)
  "you dont need a macro for this"
  `(* ,x ,x ,x))
(mapcar #'cube (list 1 2 3 4)) ; > error macro not function

redefining a macro requires recompiling all functions that use it to be updated
a macro is not called at runtime, because it expands to code at compile time
(defmacro madd (x)
  `(+ 1 ,x))
(defun adder (x)
  (madd x))
(adder 1) ; > 2, even if we recompile madd, must recompile adder to update

slime-macroexpand-all will reveal that the macro has been included in the function at compilation
slime-who-calls functions
slime-who-references symbols
slime-who-macroexpands macros
  jumps to a file, which we may C-c C-k  slime-compile-and-load to recompile all
  but you probably dont need a macro. use them lightly

;; comma-splice
does not require a macro to use

(list :params (loop for i to 2 collect i)) ; => (:PARAMS (0 1 2))
`(:params ,@(loop for i to 2 collect i)) ; => (:PARAMS 0 1 2)

(defmacro mrest (@rest rest)
  (format t "rest is: ~S" rest)
  ~(progn
     ,@rest))

;;body

(defmacro with-body (&body body)
  `(progn ,@body))
(with-body
  (print :body))

(defmacro my-dolist ((var expr) &body body)
  `(loop for ,var in ,expr do
         (progn
           ,@body)))
(my-dolist (x '(1 2 3))
  (print x))

;;
(defmacro with-echo (&body body)
  `(format nil "the result of ~S is ~S"
           (quote ,@body)
           (progn ,@body)))
(with-echo (+ 1 1))

;; gensym
subtle bugs due to variable capture without this

;; call-with pattern
makes reasoning and testing macros easier

(defun call-with-repeat (times function)
  (loop for x from 1 to times do
        (funcall function)))
(defmacro repeat (times &body body)
  `(call-with-repeat ,times (lambda () ,@body)))
(let ((x "hi"))
  (repeat 3 (print x)))

;; compile time computing
use to reduce execution calculations and for developer errors at compile time
defun*

;; lists vs AST
CL macros manipulates lists of symbols

;; symbol-macro

;; read time evaluation with #.

;; macro-step
#+end_src

** CLOS
;; pretty printing
;; defclass
;; custom constructors
;; initialize-instance
;; multiple inheritance
;; defgeneric vs defmethod
;; class allocation
** quoting data
** logic
** control
* Interop
** Cmd
Calls to command line, protected and various return types
https://github.com/ruricolist/cmd

#+begin_src lisp
                                          ; Loading
  (ql:quickload :cmd)
  (use-package :cmd)

                                          ; Usage
  ($cmd "ls")
  ($sh "cd ~; ls")
  ($sh "pwd")
  ($cmd "echo a b \
                    c \
                    d")

  ($cmd "echo 'hello world' >> text.txt")
  ($cmd "echo 'hello world' > text.txt")

  (defun call-cmd (arg arg1)
    ($cmd (format nil "echo hello:
                                   ~A
                                   ~A" arg arg1)))
  (call-cmd "Lamb" "Duh")

                                          ; &&& return types
  (cmd "cmd")
  ($cmd "cmd")
  ($sh "cmd")

#+end_src

** py4cl2

Calls to and imports from Python
https://github.com/digikar99/py4cl2

#+begin_src lisp

  (ql:quickload :py4cl2)
  (use-package :py4cl2)

                                          ; first time manually initialize
  ;; (py4cl2:initialize)
  ;; ;; python3, ret, ret, ret
  ;; (print py4cl2:*config*)
  ;; (setf (config-var pycmd) "python3") ; set one field

                                          ; test if pycmd finds python on path
  (py4cl2:pyversion-info)    ; fails if python command is not resolved

                                          ; test usage
  (py4cl2:pyexec "print(\"hello\")")    ; => hello
  (py4cl2:defpymodule "math")
  (py4cl2:pyeval "math.pi")             ; 3.1415...
  (py4cl2:defpymodule "numpy" nil :lisp-package "NP")
  (np:floor 4.2)                        ; => 4.0
  (py4cl2:pyeval "[i**2 for i in range(5)]")

                                          ; import and environment
  (defpymodule "os" nil :lisp-package "OS")
  (defpymodule "sys" nil :lisp-package "SYS")
  (defpymodule "pprint" nil :lisp-package "PPRINT")
  (pyexec "sys.path.append('/home/user/code/dircontainingscript')")
  (pyexec "sys.path.append('/home/user/.local/lib/python3.10/site-packages')")
  (pyexec "sys.path.append('/home/user/.guix-profile/lib/python3.10/site-packages')")
  ;; check python path contains target and path to imported modules
  (pyexec "pprint.pprint(sys.path)")
  (os:getcwd)
  (os:listdir)

                                          ; test setup
  ;; NOTE: files on path cannot have '-' in them or defpymodule fails, with NIL!!!
  ;; NOTE: If the file has a compilation error, then import will return NIL!!!
  ;; NOTE: unresolved module import is one such silent failure mode.
  ;; create pytest.py on python path which contains the following.
  ;; ======================================
  ;; def test():
  ;;     print("test sucessfull")

  ;; def argument(a):
  ;;     print(a)

  ;; def math(x):
  ;;   y = x * x
  ;;   return y
  ;; ======================================

                                          ; test import script on path
  (defpymodule "pytest" nil :lisp-package "PYTEST")
  (pytest:test)
  (pytest:argument :a "hello")
  (pytest:argument :a 42)
  (pytest:math :x 9)
  ;; must stop and restart to re import with changes

                                          ; stop
  (py4cl2:pystop)
  (py4cl2:python-alive-p)

#+end_src

** Clesh
https://github.com/Neronus/clesh
clesh is included here mostly to show off how
flexible lisp can be, this is almost unthinkable in other languages, yet it is
transparently available without core language changes.

I recommend using cmd over clesh for permanent work, but for experimental, fast
tasks, scripts etc this mixed inlining is very handy indeed. cmd is more
controlable and disciplined and better suited for wrapping calls for serious
use.

#+begin_src lisp
                                          ; load
  (ql:quickload :clesh)
  (use-package :named-readtables)
  (in-readtable clesh:syntax)

                                          ; usage
  ;; repl out
  !ls
  !echo ?(+ 2 3) foo 5 bar

  ;;messages out
  [echo one two three] ;call bash command
  [echo one ?(+ 1 1) three] ;call lisp command in bash command
  (princ [echo foo]) ;call bash command in lisp command

  (defparameter *val* 42)
  [echo one ?*val* three] ;sub lisp var in bash arg
  [echo one ?(princ *val*) three] ;sub lisp command in bash arg

  ;; break bash commands
  [echo one \
  two \
  three]

  (princ [echo one \
         ?*val* \
         three]) ;sub lisp var in bash arg

  (princ [echo one \
         ?(+ *val* *val*) \
         three]) ;sub lisp command in bash arg

  ;; within a function
  (defun call-clesh (arg arg1)
    [echo \
    Hello: \
    ?arg \
    "FOO" ?arg1])
  (call-clesh "Lamb" "Duh")
#+end_src

** Scripting with CL

*** guides

-  sly adapted as shell https://web.archive.org/web/20210730202847/https://ambrevar.xyz/lisp-repl-shell/index.html
- https://simonsafar.com/2021/lisp_scripting/
- https://fare.livejournal.com/184127.html
- https://atomized.org/blog/2020/07/06/common-lisp-in-practice/
- shell wrapper https://www.cliki.net/CL-Launch

*** command line args

unix-opts
https://github.com/libre-man/unix-opts

The UNIX command line args can be read from the variable =sb-ext:*posix-argv*=

*** export binaries

(uiop/image: &&&)

** &&& clojure R etc
TODO Unified example of library interop, and program interop to minimal program with one argument for each lang
* Packages

TODO dig into ciel-lang, for inspiration and spare parts and packages
It looks like a well intentioned project but the deployment is awfull.
https://github.com/ciel-lang/CIEL

** strings

str
https://github.com/vindarel/cl-str

(str:split " " "hello world") ; => ("hello" "world")
(str:replace-all old new string)
(str:lines &&&)

regex
https://edicl.github.io/cl-ppcre/

time
https://local-time.common-lisp.dev/

** Testing
https://github.com/lmj/1am
https://github.com/AccelerationNet/lisp-unit2
** GUI

clog common lisp omnificient gui
https://rabbibotton.github.io/clog/cltt.pdf

** Logging

https://shinmera.github.io/verbose/

** iteration
*** built in

#+begin_src lisp
  ;;dotimes
  (dotimes (n 3)
    (print n))

  ;;dolist
  (dolist (i '(1 2 3))
    (print i))

  ;;mapcar
  (mapcar #'print '(1 2 3))

  ;; There is also the built in loop macro, its syntax is powerful, but non idiomatic
#+end_src

*** iterate

https://iterate.common-lisp.dev

#+begin_src lisp
  (ql:quickload :iterate)
  (use-package :iterate)

  (iterate:display-iterate-clauses)

  (defparameter *my-vector* #(1.1 2.2 3.3 4.4))
  (defparameter *my-list* '(1 2 3 4))

  (defparameter *my-hashtable* (make-hash-table))
  (setf (gethash 'a *my-hashtable*) 10)
  (setf (gethash 'b *my-hashtable*) 20)
  (setf (gethash 'c *my-hashtable*) 30)

  ;; hashtables
  (iter (for (k v) in-hashtable *my-hashtable*)
    (collect (cons k v)))

  ;; List iteration
  (iter (for i in *my-list*)
    (collect i))

  ;; Vector iteration
  (iter (for v in-vector *my-vector*)
    (collect v))

  ;; ranges
  (iter (for i from 1 to 10)
    (collect i))
  (for i upfrom 0)
  (for i from 5)
  (for i downfrom 0)
  (for i from  1 to 10)
  (for i from 1 below 10)
  (for i from 1 to 10 by 2)
  (for i from 10 downto 1)

  ;; Nested iterations:
  (iter outer (for i from 1 to 3)
    (iter (for j from 1 to 3)
      (in outer (collect (list i j)))))

  ;; Conditional collection:
  (iter (for i from 1 to 10)
    (when (evenp i)
      (collect i)))

  ;; Summing:
  (iter (for i in '(1 2 3 4 5))
    (sum i))

  ;; Finding maximum:
  (iter (for i in '(3 7 2 9 1))
    (maximize i))

  ;; String iteration:
  (iter (for char in-string "Hello")
    (collect (char-upcase char)))

  ;; Iterating with multiple variables:
  (iter (for i from 1 to 5)
    (for j from 10 downto 6)
    (collect (list i j)))

  (iter (for i from 1 to 5)
    (for j from 1 to i)
    (collect (list i j))) &&&

  ;; Early termination:
  (iter (for i from 1)
    (while (< i 5))
    (collect i))

                                            ; Simple iteration over a range:
    (iter (for i from 1 to 10)
      (sum i))

                                            ; Simple iteration over a list:
    (iter (for x in '(1 2 3 4 5))
      (sum x))

                                            ; Iterating over a range of numbers:
    (iter (for i from 1 to 5)
      (collect (* i i)))

    (iter (for i from 1 to 5)
      (sum (* i i)))

                                            ; Iterating over a hash table:
    (let ((ht (make-hash-table)))
      (setf (gethash 'a ht) 1
            (gethash 'b ht) 2
            (gethash 'c ht) 3)
      (iterate (for (k v) in-hashtable ht)
        (collect (list k v))))
                                            ; => ((C 3) (B 2) (A 1))

                                            ; Nested iteration:
    (iter (for i from 1 to 3)
      (collect (iterate (for j from 1 to i)
                 (collect j))))
                                            ; => ((1) (1 2) (1 2 3))
#+end_src

** event scheduling
*** click

&&& Initialization functions custom to click
- on-start
- on-project

*** clerk

#+begin_src lisp
  (ql:quickload :clerk)
  (use-package :clerk)

  ;; Make sure your jobs are loaded before executing (clerk:start)
  ;; &&&verify
  (clerk:job "Say 'Hello' often" every 5.seconds (print "Hello"))
  (clerk:start)
  (clerk:stop)

  (defun bark ()
    (print "Bark!"))

  (clerk:job "The dog barks" every 7.seconds (bark))
  (clerk:start)
  (clerk:stop)

  ;; The jobs reside inside clerk:*jobs*,
  (dolist (j clerk:*jobs*)
    (print j))
  ;; list of all scheduled and running jobs.
  (clerk:calendar)

  (clerk:empty-jobs-queue)
  (clerk:calendar)

  ;; all examples above are continuous jobs, set with every
  ;; one time jobs are also available
  ;; use in  or after to set one time jobs
  (clerk:job "Say 'Hello' often" every 5.seconds (print "Hello"))
  (clerk:start)
  (clerk:job "Bark once" in 15.seconds (bark))
  (clerk:calendar)
  (clerk:stop)
  (clerk:empty-jobs-queue)

  ;;programmatic setup
  (defparameter *query-interval* 30)
  (clerk:job-function (format nil "Task set for every: ~A seconds" *query-interval*)
                      'every `(,*query-interval* seconds)
                      #'bark) ; requires a function symbol or lambda
#+end_src

Intervals

interval-type is one of the following (plural is equivalent, ie minute = minutes):
second minute hour day week month year
=<+ve integer>.<interval>=

or Days of the week
if you type the day of the week, clerk will calculate when it is and add an event to the queue.
=(job "Weekly report" every monday (create-report))=

** database

mito
https://github.com/fukamachi/mito

** math

in hyperspec as numbers
https://novaspec.org/cl/12_1_Number_Concepts

** data structures

reading
- https://blog.djhaskin.com/blog/common-data-structures-in-common-lisp/

access uniformity
https://github.com/AccelerationNet/access/

fset
https://github.com/slburson/fset

gmap
https://github.com/slburson/misc-extensions

listopia
https://github.com/Dimercel/listopia

*** a and p lists

&&&

*** hashtables

#+begin_src lisp
                                          ; Creating and using a simple hashtable:
  (defvar *fruit-prices* (make-hash-table :test #'equal))

  (setf (gethash "apple" *fruit-prices*) 0.50)
  (setf (gethash "banana" *fruit-prices*) 0.75)

  (format t "An apple costs $~A~%" (gethash "apple" *fruit-prices*))

                                          ; Using gethash with a default value:
  (defvar *user-scores* (make-hash-table))

  (setf (gethash "Alice" *user-scores*) 100)

  (format t "Bob's score: ~A~%" (gethash "Bob" *user-scores* 0))

                                          ; Iterating over a hashtable:
  (defvar *capitals* (make-hash-table :test #'equal))
  (setf (gethash "France" *capitals*) "Paris"
        (gethash "Japan" *capitals*) "Tokyo")

  (maphash #'(lambda (country capital)
               (format t "The capital of ~A is ~A~%" country capital))
           ,*capitals*)

                                          ; Removing an entry and checking the count:
  (defvar *inventory* (make-hash-table))
  (setf (gethash 'book *inventory*) 5
        (gethash 'pen *inventory*) 10)

  (remhash 'book *inventory*)
  (format t "Items in inventory: ~A~%" (hash-table-count *inventory*))
#+end_src

** Data formats IO

json
https://github.com/Zulu-Inuoe/jzon/

csv
https://github.com/AccelerationNet/cl-csv

xlsx
https://github.com/defunkydrummer/lisp-xl
on github &&& install notes

** distribution

*** quicklisp

https://www.quicklisp.org/beta/
https://common-lisp-libraries.readthedocs.io/quicklisp/

check installed dists
(ql-dist:all-dists)

&&&note on
(quicklisp:update-all-dists)

&&& how to uninstal dists
&&&reinstall dists

*** ultralisp

https://ultralisp.org/

*** asdf

https://asdf.common-lisp.dev/

* Help

quicksearch
https://github.com/lisp-maintainers/quicksearch

TODO (help) and (help "symbol")
should be an interactive menu describing the options/ letting user go on to any or all sub
(help "help") should go give detailed descriptions of each  option

package help
symbol help
namespace help

#+begin_src lisp
  ;;search quicklisp dists for a package
  (ql:system-apropos "find-me")
  ;;search all dists and github for a package
  (quicksearch:quicksearch "find-me")

  ;;inspect
  (inspect "string")
  ;;describe
  (describe "string")
  ;;apropos
  (apropos "string")
  ;;documentation
  (documentation "string")
#+end_src

** Acknowledgements
Smarter programmers than I have gone these ways, I have made this because I am a simple and silly sheep.

** Resources

ESSENTIAL


syntax crash course
https://learnxinyminutes.com/docs/common-lisp/

lisp crash course
https://cs.gmu.edu/~sean/lisp/LispTutorial.html

use the cookbook
https://lispcookbook.github.io/cl-cookbook/

hyperspec
https://www.lispworks.com/documentation/HyperSpec/Front/

novaspec
https://novaspec.org/cl/

awesome common lisp list
https://github.com/CodyReichert/awesome-cl

defacto libraries docs page
https://common-lisp-libraries.readthedocs.io/
- asdf - Build System
- alexandria - Commonly Used Utilities
- bordeaux-threads - Threading
- cl-ppcre - Regular Expressions
- cl-who - DSL for Markup
- fiveam - Regression Testing Framework
- hunchentoot - Web Server
- iterate - Psuedocodic Iteration
- local-time - Date and Time Manipulation
- postmodern - PostgreSQL programming interace
- quicklisp - Library Manager
- usocket - Universal Socket Library
- utilities - A collection of utility libraries
- numcl - Lispy clone of numpy
- unix-opts - cmd line argument parser



GUIDES
- great teacher https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/
- learn lisp the hard way https://llthw.common-lisp.dev/
- another terser cookbook https://cl-cookbook.sourceforge.net/index.html
- common lisp by example http://csci.viu.ca/~wesselsd/courses/csci330/code/sbcl-lisp/index.html
- successful lisp book https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/contents.html

WATCHING
- https://www.youtube.com/@the-lisper/videos
- https://www.youtube.com/watch?v=0RQYa2XJBKU
- https://www.youtube.com/@philipbohun740/videos
- https://www.youtube.com/watch?v=rmUTW5QWhhM&list=PL2VAYZE_4wRJi_vgpjsH75kMhN4KsuzR_&index=2

LIBRARIES
- asdf docs https://asdf.common-lisp.dev/
- alexandria docs https://alexandria.common-lisp.dev/draft/alexandria.html

REFERENCE
- common lisp wiki, almost every CL package https://www.cliki.net/
- technical syntax quick reference http://clqr.boundp.org/clqr-a4-consec.pdf
- sbcl man http://www.sbcl.org/manual
- quicklisp links to docs https://quickref.common-lisp.net/index-per-library.html
- quicklisp catalogue https://www.quicklisp.org/beta/UNOFFICIAL/docs/
- quicklisp search https://quickdocs.org/
- ql heavy hitters https://github.com/vindarel/lisp-maintainers
- documentation redirect service http://l1sp.org/html/
- googles lisp style guide https://google.github.io/styleguide/lispguide.xml
- style guide http://mumble.net/~campbell/scheme/style.txt

READING
- advanced functional programming https://www2.cs.sfu.ca/CourseCentral/310/pwfong/Lisp/2/tutorial2.html
- page 13 explained in pythoooon https://michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/
- page 13 in modern scheme https://www.gnu.org/software/mes/manual/html_node/LISP-as-Maxwell_0027s-Equations-of-Software.html
- LOL book https://letoverlambda.com/index.cl/toc
- blog and lisp bibliography https://simondobson.org/writing/
- lisp nn from primitives https://woodrush.github.io/blog/posts/2022-01-16-neural-networks-in-pure-lisp.html
- interactive programming implications https://www.n16f.net/blog/interactive-common-lisp-development/

CITATIONS FOR LISP PAPERS
- https://www.math.fau.de/wp-content/uploads/2020/09/Preprint-2002-40-scan.pdf
&&& bring other lisp citations here!

* CLEAN
Common Lisp Environment for Experiment and Analysis

All advanced data science ML and modelling goes here
If click is the living room clean is the laboratory

I want an operating system for data science,
deployable pipelines and experiment tracking is the goal

declarative file system state
https://github.com/Virtual-Insurance-Products/cl-sysop

Depot
file system protocol browse read write with locks and ACID safety
https://shinmera.github.io/depot/

clml machine learning
https://github.com/mmaul/clml

cl-ana
data frames stats and dependency oriented programming
https://github.com/ghollisjr/cl-ana/wiki

memoization
https://github.com/AccelerationNet/function-cache

ML
https://github.com/melisgl/mgl

nvidia interop
https://github.com/takagi/cl-cuda

lispstat - linear algebra - stats - plot
https://lisp-stat.dev/
#+begin_src lisp
                                          ; RE bug on loading in guix
                                          ; Cffi path Ref: https://lists.gnu.org/archive/html/bug-guix/2020-01/msg00133.html
(ql:quickload :lisp-stat) ; stats

                                          ; usage&&&
#+end_src

deep learning matrices matrices
https://github.com/hikettei/cl-waffe2

syntax modification useful for data pipelines
https://quickref.common-lisp.net/arrows.html

numcl, numpy clone
https://numcl.github.io/numcl/
#+begin_src lisp
                                          ; Creating and manipulating arrays:
  (numcl:array '(1 2 3 4 5))  ; Create a 1D array
  (numcl:zeros '(3 3))        ; Create a 3x3 array of zeros
  (numcl:aref my-array 1 2)   ; Access element at row 1, column 2

                                          ; Basic operations:
  (numcl:+ (numcl:array '(1 2 3)) (numcl:array '(4 5 6)))  ; Element-wise addition
  (numcl:* (numcl:array '(1 2 3)) 2)                       ; Scalar multiplication

                                          ; Mathematical functions:
  (numcl:sin (numcl:array '(0 (/ pi 2) pi)))  ; Element-wise sine
  (numcl:exp (numcl:array '(0 1 2)))          ; Element-wise exponential

                                          ; Linear algebra:
  (numcl:matmul matrix1 matrix2)  ; Matrix multiplication
  (numcl:transpose my-matrix)     ; Matrix transposition
#+end_src

&&& gnu scientific library for cl

System info
https://github.com/Shinmera/machine-state/

** lparallel

#+begin_src lisp
                                          ; lparallel startup
  (ql:quickload :lparallel)
  (use-package :lparallel)
  (setf lparallel:*kernel* (lparallel:make-kernel 8)) ;set worker threads

                                          ; env setup for examples
  (defun gt-five (x)
    (if (> x 5)
        x))

  (defun lt-five (x)
    (if (< x 5)
        x))

  (defparameter *mylist* '(0 1 2 3 4 5 6 7 8 9 10) )

                                          ; usage
  (pmap 'list (lambda (x) (* x x)) '(1 2 3 4))
  (preduce #'+ #(1 2 3 4 5))

  (premove '5 '(1 2 3 4 5 6 7 8 9 0))

  (premove-if (lambda (x) (> x 5)) '(0 1 2 3 4 5 6 7 8 9 10))
  (premove-if #'gt-five '(0 1 2 3 4 5 6 7 8 9 10))
  (premove-if #'gt-five *mylist*)

  (premove-if-not #'gt-five *mylist*)
  (premove-if #'gt-five *mylist*)
  (premove-if #'lt-five *mylist*)
  (premove-if-not #'lt-five *mylist*)

  (defun my-filter (predicate list)
    (reduce 'nreconc
            (lparallel:preduce-partial (lambda (acc x)
                                         (if (funcall predicate x)
                                             acc
                                             (cons x acc)))
                                       list
                                       :initial-value nil)
            :initial-value nil
            :from-end t))

  (my-filter #'gt-five *mylist*)
  #+end_src

** generators

gtwiwtg - generators the way I want them generated
https://github.com/d3v3l0/gtwiwtg
https://cicadas.surf/cgit/colin/gtwiwtg.git/about/
clear and modernized and documented


series
https://github.com/rtoy/cl-series
A high quality high perf, classic lib but docs and examples are hard to find

** types

coalton
https://github.com/coalton-lang/coalton/
